# Сборка заказа целиком из исходных текстов в системе развертывания #
Последовательность сборки:
1. создание чистой среды;
2. получение исходных текстов;
3. сборка;
4. версионирование артефактов;
5. заливка в систему хранения артефактов.

Итак, по шагам.

## Создание чистой среды ##
Чистой средой, вероятнее всего, будет являться виртуальная машина, поднятая с помощью какого-либо контейнера (Vagrant, Docker).
Чистой средой является ОС, ее настройки, стороннее ПО, их настройки.
Все это должно где-то храниться слоями.

## Получение исходных текстов ##
Предполагается, что проекты заказа добавляются в заказ в виде подмодулей git проекта заказа.
В этом случае для получения исходных текстов проектов определенной версии определенного заказа необходимо пройти через несколько шагов:
1. Получение репозитория заказа из хранилища репозиториев - `clone`.
2. Переход на нужную версию заказа - `checkout`.
	В результате будут получены исходные тексты конфигурации заказа, в том числе список проектов заказа в файле `.gitmodules`.
3. Получение репозиториев проектов заказа из хранилища репозиториев - `submodule init`.

После этих шагов в каталоге с заказом находятся исходные тексты всех проектов, входящих в заказ на определенный момент времени.

---
**Вопрос:** Каким образом держать под контролем `.gitmodules`? В нем содержится два вида информации:
- заказозависимая - список проектов, входящих в состав заказа в данный момент времени;
- инфраструктурная - путь к серверу хранилища репозиториев.

По хорошему такого рода информация должна быть разделена и храниться отдельно.
Более того, инфраструктурная информация вообще не должна храниться в заказе.

Есть еще один связанный вопрос: помимо пути к серверу хранилища репозиториев в `.gitmodules` также хранится путь и название проекта в хранилище репозиториев. Непонятно, что делать, если этот путь будет изменен в системе управления репозиториями.
На первый взгляд кажется, что в этом случае можно было бы попытаться изменить пути в каждом из заказов автоматически.
Но проблема в том, что изменить пути можно будет только в последней версии заказа, а в предыдущих версиях они останутся старыми.
Пока что единственным выходом видится запрет на изменение путей к проектам в хранилище репозиториев после включения конкретного проекта в какой-либо заказ.
---

## Сборка ##
Сборка заказа осуществляется системой сборки `cmake`.
`cmake` передается файл `CMakeLists.txt`, содержащийся в проекте заказа.
В этом файле содержится или может быть получен список проектов, входящих в данный заказ.

`cmake` самостоятельно, учитывая зависимости, собирает все проекты заказа.
По окончании сборки появляется каталог с артефактами сборки.

---
**Вопрос:** каким образом исключить дублирование списка проектов с файлом `.gitmodules`?
Использовать какие-то инструменты git?

Возможно ли, что в заказ будут входить проекты, которые не должны собираться?
Или проекты, в которых должны собираться не все артефакты?
Развернутый вопрос [тут](compile-and-install-lists.md "списки сборки и установки").
---

## Версионирование артефактов ##
Собранные артефакты необходимо пометить.
Пометка зависит от следующих факторов:
- версия исходных текстов артефакта ([см. тут](source-versioning.md "версионирование исходных текстов"));
- версии зависимостей, с которыми собирался артефакт;
- контрольная сумма.

## Заливка в систему хранения артефактов ##
???
